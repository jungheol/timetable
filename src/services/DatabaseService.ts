import * as SQLite from 'expo-sqlite';
import moment from 'moment';

export interface Schedule {
  id: number;
  name: string;
  start_time: string;
  end_time: string;
  show_weekend: boolean;
  is_active: boolean;
  time_unit?: '30min' | '1hour';
  created_at?: string;
  updated_at?: string;
  del_yn?: boolean;
}

export interface Event {
  id: number;
  schedule_id: number;
  title: string;
  start_time: string;
  end_time: string;
  event_date?: string;
  category: 'ÌïôÍµê/Í∏∞Í¥Ä' | 'ÌïôÏõê' | 'Í≥µÎ∂Ä' | 'Ìú¥Ïãù' | 'ÏÑ†ÌÉùÏïàÌï®';
  academy_id?: number;
  is_recurring: boolean;
  recurring_group_id?: number;
  created_at?: string;
  updated_at?: string;
  del_yn?: boolean;
}

export interface Academy {
  id: number;
  schedule_id: number;
  name: string;
  subject: 'Íµ≠Ïñ¥' | 'ÏàòÌïô' | 'ÏòÅÏñ¥' | 'ÏòàÏ≤¥Îä•' | 'ÏÇ¨ÌöåÍ≥ºÌïô' | 'Í∏∞ÌÉÄ';
  monthly_fee?: number;
  payment_cycle?: number;
  payment_method?: 'Ïπ¥Îìú' | 'Ïù¥Ï≤¥';
  payment_day?: number;
  payment_institution?: string;
  payment_account?: string;
  textbook_fee?: number;
  textbook_bank?: string;
  textbook_account?: string;
  start_month?: string;
  end_month?: string;
  status: 'ÏßÑÌñâ' | 'Ï§ëÎã®';
  provides_vehicle?: boolean;
  note?: string;
  created_at?: string;
  updated_at?: string;
  del_yn?: boolean;
}

export interface RecurringPattern {
  id: number;
  monday: boolean;
  tuesday: boolean;
  wednesday: boolean;
  thursday: boolean;
  friday: boolean;
  saturday: boolean;
  sunday: boolean;
  start_date: string;
  end_date?: string;
  created_at?: string;
  del_yn?: boolean;
}

export interface RecurringException {
  id: number;
  recurring_event_id: number;
  exception_date: string;           // YYYY-MM-DD
  exception_type: 'modify' | 'cancel';
  
  // ÏàòÏ†ïÎêú ÎÇ¥Ïö© (modifyÏù∏ Í≤ΩÏö∞)
  modified_title?: string;
  modified_start_time?: string;
  modified_end_time?: string;
  modified_category?: 'ÌïôÍµê/Í∏∞Í¥Ä' | 'ÌïôÏõê' | 'Í≥µÎ∂Ä' | 'Ìú¥Ïãù' | 'ÏÑ†ÌÉùÏïàÌï®';
  modified_academy_id?: number;
  
  created_at?: string;
  updated_at?: string;
  del_yn?: boolean;
}

export interface Holiday {
  id: number;
  date: string;           // YYYY-MM-DD ÌòïÏãù
  name: string;           // Í≥µÌú¥ÏùºÎ™Ö
  is_holiday: boolean;    // Í≥µÌú¥Ïùº Ïó¨Î∂Ä
  year: number;           // Ïó∞ÎèÑ
  month: number;          // Ïõî
  day: number;            // Ïùº
  created_at?: string;
  updated_at?: string;
  del_yn?: boolean;
}

// ÌÜµÍ≥Ñ Í¥ÄÎ†® Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
export interface AcademyExpenseStats {
  academy_id: number;
  academy_name: string;
  subject: string;
  total_expense: number;
  monthly_fee: number;
  payment_cycle: number;
  months_count: number;
}

export interface MonthlyExpenseStats {
  subject: string;
  total_expense: number;
  academy_count: number;
}

export interface MonthlyStudyStats {
  subject: string;
  total_hours: number;
  academy_name?: string;
}

class DatabaseService {
  private db: SQLite.SQLiteDatabase | null = null;

  // üîß Í∞úÎ∞ú Î™®Îìú ÏÑ§Ï†ï
  private DEVELOPMENT_MODE = true;

  constructor() {
    this.initDatabase();
  }

  // ‚úÖ Boolean Îç∞Ïù¥ÌÑ∞ Ï†ïÏ†ú Î©îÏÑúÎìúÎì§ Ï∂îÍ∞Ä
  private sanitizeScheduleData(rawData: any): Schedule {
    return {
      ...rawData,
      show_weekend: Boolean(rawData.show_weekend),
      is_active: Boolean(rawData.is_active),
      del_yn: Boolean(rawData.del_yn),
    };
  }

  private sanitizeEventData(rawData: any): Event {
    return {
      ...rawData,
      is_recurring: Boolean(rawData.is_recurring),
      del_yn: Boolean(rawData.del_yn),
    };
  }

  private sanitizeAcademyData(rawData: any): Academy {
    return {
      ...rawData,
      provides_vehicle: Boolean(rawData.provides_vehicle),
      del_yn: Boolean(rawData.del_yn),
    };
  }

  private sanitizeRecurringPatternData(rawData: any): RecurringPattern {
    return {
      ...rawData,
      monday: Boolean(rawData.monday),
      tuesday: Boolean(rawData.tuesday),
      wednesday: Boolean(rawData.wednesday),
      thursday: Boolean(rawData.thursday),
      friday: Boolean(rawData.friday),
      saturday: Boolean(rawData.saturday),
      sunday: Boolean(rawData.sunday),
      del_yn: Boolean(rawData.del_yn),
    };
  }

  private sanitizeRecurringExceptionData(rawData: any): RecurringException {
    return {
      ...rawData,
      del_yn: Boolean(rawData.del_yn),
    };
  }

  private sanitizeHolidayData(rawData: any): Holiday {
    return {
      ...rawData,
      is_holiday: Boolean(rawData.is_holiday),
      del_yn: Boolean(rawData.del_yn),
    };
  }

  // ‚úÖ Î∞∞Ïó¥ Ï†ïÏ†ú Î©îÏÑúÎìúÎì§
  private sanitizeScheduleArray(rawArray: any[]): Schedule[] {
    return rawArray.map(item => this.sanitizeScheduleData(item));
  }

  private sanitizeEventArray(rawArray: any[]): Event[] {
    return rawArray.map(item => this.sanitizeEventData(item));
  }

  private sanitizeAcademyArray(rawArray: any[]): Academy[] {
    return rawArray.map(item => this.sanitizeAcademyData(item));
  }

  private sanitizeHolidayArray(rawArray: any[]): Holiday[] {
    return rawArray.map(item => this.sanitizeHolidayData(item));
  }

  private async initDatabase() {
    try {
      this.db = await SQLite.openDatabaseAsync('student_schedule.db');

      // üîß Í∞úÎ∞ú Î™®ÎìúÏùº Îïå Î™®Îì† ÌÖåÏù¥Î∏î ÏÇ≠Ï†ú ÌõÑ Ïû¨ÏÉùÏÑ±
      if (this.DEVELOPMENT_MODE) {
        console.log('üîß Development mode: Dropping all tables...');
        await this.db.execAsync(`DROP TABLE IF EXISTS events;`);
        await this.db.execAsync(`DROP TABLE IF EXISTS academies;`);
        await this.db.execAsync(`DROP TABLE IF EXISTS recurring_patterns;`);
        await this.db.execAsync(`DROP TABLE IF EXISTS schedules;`);
        await this.db.execAsync(`DROP TABLE IF EXISTS holidays;`);
        await this.db.execAsync(`DROP TABLE IF EXISTS recurring_exceptions;`);
        console.log('‚úÖ All tables dropped');
      }
      
      // ÏùºÏ†ïÌëú ÌÖåÏù¥Î∏î
      await this.db.execAsync(`
        CREATE TABLE IF NOT EXISTS schedules (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          start_time TEXT NOT NULL,
          end_time TEXT NOT NULL,
          show_weekend BOOLEAN DEFAULT FALSE,
          is_active BOOLEAN DEFAULT TRUE,
          time_unit TEXT DEFAULT '1hour',
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          del_yn BOOLEAN DEFAULT FALSE
        );
      `);

      // Î∞òÎ≥µ Ìå®ÌÑ¥ ÌÖåÏù¥Î∏î
      await this.db.execAsync(`
        CREATE TABLE IF NOT EXISTS recurring_patterns (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          monday BOOLEAN DEFAULT FALSE,
          tuesday BOOLEAN DEFAULT FALSE,
          wednesday BOOLEAN DEFAULT FALSE,
          thursday BOOLEAN DEFAULT FALSE,
          friday BOOLEAN DEFAULT FALSE,
          saturday BOOLEAN DEFAULT FALSE,
          sunday BOOLEAN DEFAULT FALSE,
          start_date TEXT NOT NULL,
          end_date TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          del_yn BOOLEAN DEFAULT FALSE
        );
      `);

      // Î∞òÎ≥µ ÏòàÏô∏ Ìå®ÌÑ¥ ÌÖåÏù¥Î∏î
      await this.db.execAsync(`
        CREATE TABLE IF NOT EXISTS recurring_exceptions (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          recurring_event_id INTEGER NOT NULL,
          exception_date TEXT NOT NULL,
          exception_type TEXT CHECK(exception_type IN ('modify', 'cancel')) NOT NULL,
          
          modified_title TEXT,
          modified_start_time TEXT,
          modified_end_time TEXT,
          modified_category TEXT CHECK(modified_category IN ('ÌïôÍµê/Í∏∞Í¥Ä', 'ÌïôÏõê', 'Í≥µÎ∂Ä', 'Ìú¥Ïãù', 'ÏÑ†ÌÉùÏïàÌï®')),
          modified_academy_id INTEGER,
          
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          del_yn BOOLEAN DEFAULT FALSE,
          
          FOREIGN KEY (recurring_event_id) REFERENCES events(id),
          FOREIGN KEY (modified_academy_id) REFERENCES academies(id),
          UNIQUE(recurring_event_id, exception_date)
        );
      `);

      // ÌïôÏõê ÌÖåÏù¥Î∏î
      await this.db.execAsync(`
        CREATE TABLE IF NOT EXISTS academies (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          schedule_id INTEGER NOT NULL,
          name TEXT NOT NULL,
          subject TEXT CHECK(subject IN ('Íµ≠Ïñ¥', 'ÏàòÌïô', 'ÏòÅÏñ¥', 'ÏòàÏ≤¥Îä•', 'ÏÇ¨ÌöåÍ≥ºÌïô', 'Í∏∞ÌÉÄ')),
          monthly_fee INTEGER,
          payment_cycle INTEGER DEFAULT 1,
          payment_method TEXT CHECK(payment_method IN ('Ïπ¥Îìú', 'Ïù¥Ï≤¥')),
          payment_day INTEGER,
          payment_institution TEXT,
          payment_account TEXT,
          textbook_fee INTEGER,
          textbook_bank TEXT,
          textbook_account TEXT,
          start_month TEXT,
          end_month TEXT,
          status TEXT CHECK(status IN ('ÏßÑÌñâ', 'Ï§ëÎã®')) DEFAULT 'ÏßÑÌñâ',
          provides_vehicle BOOLEAN DEFAULT FALSE,
          note TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          del_yn BOOLEAN DEFAULT FALSE,
          FOREIGN KEY (schedule_id) REFERENCES schedules(id)
        );
      `);

      // ÏùºÏ†ï ÌÖåÏù¥Î∏î
      await this.db.execAsync(`
        CREATE TABLE IF NOT EXISTS events (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          schedule_id INTEGER NOT NULL,
          title TEXT NOT NULL,
          start_time TEXT NOT NULL,
          end_time TEXT NOT NULL,
          event_date TEXT,
          category TEXT CHECK(category IN ('ÌïôÍµê/Í∏∞Í¥Ä', 'ÌïôÏõê', 'Í≥µÎ∂Ä', 'Ìú¥Ïãù', 'ÏÑ†ÌÉùÏïàÌï®')),
          academy_id INTEGER,
          is_recurring BOOLEAN DEFAULT FALSE,
          recurring_group_id INTEGER,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          del_yn BOOLEAN DEFAULT FALSE,
          FOREIGN KEY (schedule_id) REFERENCES schedules(id),
          FOREIGN KEY (academy_id) REFERENCES academies(id),
          FOREIGN KEY (recurring_group_id) REFERENCES recurring_patterns(id)
        );
      `);

      // Í≥µÌú¥Ïùº ÌÖåÏù¥Î∏î ÏÉùÏÑ±
      await this.db.execAsync(`
        CREATE TABLE IF NOT EXISTS holidays (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          date TEXT NOT NULL UNIQUE,
          name TEXT NOT NULL,
          is_holiday BOOLEAN DEFAULT TRUE,
          year INTEGER NOT NULL,
          month INTEGER NOT NULL,
          day INTEGER NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          del_yn BOOLEAN DEFAULT FALSE
        );
      `);

      // Ïù∏Îç±Ïä§ ÏÉùÏÑ±
      await this.db.execAsync(`
        CREATE INDEX IF NOT EXISTS idx_events_schedule_date 
        ON events(schedule_id, event_date) WHERE del_yn = FALSE;
      `);

      await this.db.execAsync(`
        CREATE INDEX IF NOT EXISTS idx_events_academy 
        ON events(academy_id) WHERE del_yn = FALSE;
      `);

      await this.db.execAsync(`
        CREATE INDEX IF NOT EXISTS idx_holidays_date 
        ON holidays(date) WHERE del_yn = FALSE;
      `);

      await this.db.execAsync(`
        CREATE INDEX IF NOT EXISTS idx_holidays_year 
        ON holidays(year) WHERE del_yn = FALSE;
      `);

      await this.db.execAsync(`
        CREATE INDEX IF NOT EXISTS idx_recurring_exceptions_event_date 
        ON recurring_exceptions(recurring_event_id, exception_date) WHERE del_yn = FALSE;
      `);

    } catch (error) {
      console.error('Database initialization error:', error);
    }
  }

  private async ensureDbConnection(): Promise<SQLite.SQLiteDatabase> {
    if (!this.db) {
      await this.initDatabase();
    }
    if (!this.db) {
      throw new Error('Database connection failed');
    }
    return this.db;
  }

  // ÏùºÏ†ïÌëú Í¥ÄÎ¶¨ (‚úÖ Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getActiveSchedule(): Promise<Schedule | null> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getFirstAsync<any>(
        'SELECT * FROM schedules WHERE is_active = 1 AND del_yn = 0 LIMIT 1'
      );
      return result ? this.sanitizeScheduleData(result) : null;
    } catch (error) {
      console.error('Error getting active schedule:', error);
      throw error;
    }
  }

  async createSchedule(schedule: Omit<Schedule, 'id' | 'created_at' | 'updated_at'>): Promise<number> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.runAsync(
        `INSERT INTO schedules (
          name, start_time, end_time, show_weekend, is_active, time_unit, del_yn
        ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          schedule.name,
          schedule.start_time,
          schedule.end_time,
          schedule.show_weekend ? 1 : 0,
          schedule.is_active ? 1 : 0,
          schedule.time_unit || '1hour',
          schedule.del_yn ? 1 : 0
        ]
      );
      return result.lastInsertRowId;
    } catch (error) {
      console.error('Error creating schedule:', error);
      throw error;
    }
  }

  async updateSchedule(schedule: Schedule): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('üîÑ [DB] Updating schedule:', schedule);
      
      await db.runAsync(
        `UPDATE schedules SET 
         name = ?, start_time = ?, end_time = ?, show_weekend = ?, 
         time_unit = ?, is_active = ?, updated_at = CURRENT_TIMESTAMP
         WHERE id = ?`,
        [
          schedule.name, 
          schedule.start_time, 
          schedule.end_time, 
          schedule.show_weekend ? 1 : 0,
          schedule.time_unit || '1hour',
          schedule.is_active ? 1 : 0,
          schedule.id
        ]
      );
      
      console.log('‚úÖ [DB] Schedule updated successfully');
      
    } catch (error) {
      console.error('‚ùå [DB] Error updating schedule:', error);
      throw error;
    }
  }

  // ‚úÖ Î™®Îì† Ïä§ÏºÄÏ§Ñ Ï°∞Ìöå (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getAllSchedules(): Promise<Schedule[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<any>(
        'SELECT * FROM schedules WHERE del_yn = 0 ORDER BY created_at DESC'
      );
      return this.sanitizeScheduleArray(result);
    } catch (error) {
      console.error('Error getting all schedules:', error);
      throw error;
    }
  }

  async getScheduleById(id: number): Promise<Schedule | null> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getFirstAsync<any>(
        'SELECT * FROM schedules WHERE id = ? AND del_yn = 0',
        [id]
      );
      return result ? this.sanitizeScheduleData(result) : null;
    } catch (error) {
      console.error('Error getting schedule by id:', error);
      throw error;
    }
  }

  // ÌäπÏ†ï Ïä§ÏºÄÏ§ÑÏùÑ ÌôúÏÑ±ÌôîÌïòÍ≥† Îã§Î•∏ Ïä§ÏºÄÏ§ÑÎì§ÏùÑ ÎπÑÌôúÏÑ±Ìôî
  async setActiveSchedule(scheduleId: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      // Î®ºÏ†Ä Î™®Îì† Ïä§ÏºÄÏ§ÑÏùÑ ÎπÑÌôúÏÑ±Ìôî
      await db.runAsync('UPDATE schedules SET is_active = 0 WHERE del_yn = 0');
      
      // ÏÑ†ÌÉùÌïú Ïä§ÏºÄÏ§ÑÎßå ÌôúÏÑ±Ìôî
      await db.runAsync('UPDATE schedules SET is_active = 1 WHERE id = ? AND del_yn = 0', [scheduleId]);
      
      console.log(`‚úÖ Schedule ${scheduleId} set as active`);
    } catch (error) {
      console.error('Error setting active schedule:', error);
      throw error;
    }
  }

  // Ïä§ÏºÄÏ§Ñ ÏÇ≠Ï†ú (ÎÖºÎ¶¨Ï†Å ÏÇ≠Ï†ú)
  async deleteSchedule(id: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      // ÏÇ≠Ï†úÌïòÎ†§Îäî Ïä§ÏºÄÏ§ÑÏù¥ ÌôúÏÑ± Ïä§ÏºÄÏ§ÑÏù∏ÏßÄ ÌôïÏù∏
      const scheduleToDelete = await db.getFirstAsync<any>(
        'SELECT * FROM schedules WHERE id = ? AND del_yn = 0',
        [id]
      );
      
      if (!scheduleToDelete) {
        throw new Error('Schedule not found');
      }
      
      const sanitizedSchedule = this.sanitizeScheduleData(scheduleToDelete);
      
      // Ïä§ÏºÄÏ§ÑÏùÑ ÎÖºÎ¶¨Ï†ÅÏúºÎ°ú ÏÇ≠Ï†ú
      await db.runAsync('UPDATE schedules SET del_yn = 1 WHERE id = ?', [id]);
      
      // ÎßåÏïΩ ÏÇ≠Ï†úÎêú Ïä§ÏºÄÏ§ÑÏù¥ ÌôúÏÑ± Ïä§ÏºÄÏ§ÑÏù¥ÏóàÎã§Î©¥, Îã§Î•∏ Ïä§ÏºÄÏ§ÑÏùÑ ÌôúÏÑ±Ìôî
      if (sanitizedSchedule.is_active) {
        const remainingSchedules = await db.getAllAsync<any>(
          'SELECT * FROM schedules WHERE del_yn = 0 ORDER BY created_at DESC LIMIT 1'
        );
        
        if (remainingSchedules.length > 0) {
          await db.runAsync('UPDATE schedules SET is_active = 1 WHERE id = ?', [remainingSchedules[0].id]);
          console.log(`‚úÖ Activated schedule ${remainingSchedules[0].id} after deletion`);
        }
      }
      
      console.log(`‚úÖ Schedule ${id} deleted`);
    } catch (error) {
      console.error('Error deleting schedule:', error);
      throw error;
    }
  }

  // ‚úÖ ÌïôÏõê Í¥ÄÎ¶¨ (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getAcademiesBySchedule(scheduleId: number): Promise<Academy[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<any>(
        'SELECT * FROM academies WHERE schedule_id = ? AND del_yn = 0 ORDER BY created_at DESC',
        [scheduleId]
      );
      return this.sanitizeAcademyArray(result);
    } catch (error) {
      console.error('Error getting academies by schedule:', error);
      throw error;
    }
  }

  async getAcademies(): Promise<Academy[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<any>(
        'SELECT * FROM academies WHERE del_yn = 0 ORDER BY created_at DESC'
      );
      return this.sanitizeAcademyArray(result);
    } catch (error) {
      console.error('Error getting academies:', error);
      throw error;
    }
  }

  async createAcademy(academy: Omit<Academy, 'id' | 'created_at' | 'updated_at'>): Promise<number> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.runAsync(
        `INSERT INTO academies (
          schedule_id, name, subject, monthly_fee, payment_cycle, payment_method, 
          payment_day, payment_institution, payment_account, textbook_fee, 
          textbook_bank, textbook_account, start_month, end_month, 
          status, provides_vehicle, note
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          academy.schedule_id,
          academy.name, 
          academy.subject, 
          academy.monthly_fee ?? null, 
          academy.payment_cycle ?? null,
          academy.payment_method ?? null, 
          academy.payment_day ?? null, 
          academy.payment_institution ?? null,
          academy.payment_account ?? null, 
          academy.textbook_fee ?? null, 
          academy.textbook_bank ?? null,
          academy.textbook_account ?? null, 
          academy.start_month ?? null, 
          academy.end_month ?? null,
          academy.status, 
          academy.provides_vehicle ? 1 : 0, 
          academy.note ?? null
        ]
      );
      return result.lastInsertRowId;
    } catch (error) {
      console.error('Error creating academy:', error);
      throw error;
    }
  }

  async updateAcademy(academy: Academy): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      await db.runAsync(
        `UPDATE academies SET 
         schedule_id = ?, name = ?, subject = ?, monthly_fee = ?, payment_cycle = ?,
         payment_method = ?, payment_day = ?, payment_institution = ?,
         payment_account = ?, textbook_fee = ?, textbook_bank = ?,
         textbook_account = ?, start_month = ?, end_month = ?,
         status = ?, provides_vehicle = ?, note = ?,
         updated_at = CURRENT_TIMESTAMP
         WHERE id = ?`,
        [
          academy.schedule_id,
          academy.name, 
          academy.subject, 
          academy.monthly_fee ?? null, 
          academy.payment_cycle ?? null,
          academy.payment_method ?? null, 
          academy.payment_day ?? null, 
          academy.payment_institution ?? null,
          academy.payment_account ?? null, 
          academy.textbook_fee ?? null, 
          academy.textbook_bank ?? null,
          academy.textbook_account ?? null, 
          academy.start_month ?? null, 
          academy.end_month ?? null,
          academy.status, 
          academy.provides_vehicle ? 1 : 0, 
          academy.note ?? null, 
          academy.id
        ]
      );
    } catch (error) {
      console.error('Error updating academy:', error);
      throw error;
    }
  }

  async deleteAcademy(id: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      await db.runAsync('UPDATE academies SET del_yn = 1 WHERE id = ?', [id]);
    } catch (error) {
      console.error('Error deleting academy:', error);
      throw error;
    }
  }

  // ‚úÖ ÏùºÏ†ï Í¥ÄÎ¶¨ (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getEvents(scheduleId: number, startDate: string, endDate: string): Promise<Event[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<any>(
        `SELECT e.*, a.name as academy_name, a.subject as academy_subject
         FROM events e
         LEFT JOIN academies a ON e.academy_id = a.id
         WHERE e.schedule_id = ? AND e.del_yn = 0
         AND ((e.is_recurring = 0 AND e.event_date BETWEEN ? AND ?)
              OR (e.is_recurring = 1))
         ORDER BY e.start_time`,
        [scheduleId, startDate, endDate]
      );
      return this.sanitizeEventArray(result);
    } catch (error) {
      console.error('Error getting events:', error);
      throw error;
    }
  }

  async createEvent(event: Omit<Event, 'id' | 'created_at' | 'updated_at'>): Promise<number> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('Creating event:', event);
      
      const result = await db.runAsync(
        `INSERT INTO events (
          schedule_id, title, start_time, end_time, event_date,
          category, academy_id, is_recurring, recurring_group_id
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          event.schedule_id, 
          event.title, 
          event.start_time, 
          event.end_time,
          event.event_date ?? null, 
          event.category, 
          event.academy_id ?? null,
          event.is_recurring ? 1 : 0, 
          event.recurring_group_id ?? null
        ]
      );
      
      console.log('Event created with ID:', result.lastInsertRowId);
      return result.lastInsertRowId;
    } catch (error) {
      console.error('Error creating event:', error);
      throw error;
    }
  }

  async updateEvent(event: Event): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      await db.runAsync(
        `UPDATE events SET 
         title = ?, start_time = ?, end_time = ?, event_date = ?,
         category = ?, academy_id = ?, updated_at = CURRENT_TIMESTAMP
         WHERE id = ?`,
        [
          event.title, 
          event.start_time, 
          event.end_time, 
          event.event_date ?? null,
          event.category, 
          event.academy_id ?? null, 
          event.id
        ]
      );
    } catch (error) {
      console.error('Error updating event:', error);
      throw error;
    }
  }

  async deleteEvent(id: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      await db.runAsync('UPDATE events SET del_yn = 1 WHERE id = ?', [id]);
    } catch (error) {
      console.error('Error deleting event:', error);
      throw error;
    }
  }

  // Îã§Ï§ë ÏöîÏùº ÏùºÏ†ï ÏÉùÏÑ± (Î∞òÎ≥µ ÏóÜÏùå)
  async createMultiDayEvents(
    eventData: Omit<Event, 'id' | 'created_at' | 'updated_at' | 'event_date'>,
    selectedDays: string[],
    baseDate: string
  ): Promise<number[]> {
    try {
      const db = await this.ensureDbConnection();
      const eventIds: number[] = [];
      
      // ÏÑ†ÌÉùÎêú ÏöîÏùºÎì§Ïóê ÎåÄÌï¥ Í∞ÅÍ∞Å Ïù¥Î≤§Ìä∏ ÏÉùÏÑ±
      for (const dayKey of selectedDays) {
        const eventDate = this.getNextDateForDay(baseDate, dayKey);
        
        const result = await db.runAsync(
          `INSERT INTO events (
            schedule_id, title, start_time, end_time, event_date,
            category, academy_id, is_recurring, recurring_group_id
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            eventData.schedule_id,
            eventData.title,
            eventData.start_time,
            eventData.end_time,
            eventDate,
            eventData.category,
            eventData.academy_id ?? null,
            false, // Îã§Ï§ë ÏöîÏùºÏù¥ÏßÄÎßå Î∞òÎ≥µÏùÄ ÏïÑÎãò
            null
          ]
        );
        
        eventIds.push(result.lastInsertRowId);
      }
      
      return eventIds;
    } catch (error) {
      console.error('Error creating multi-day events:', error);
      throw error;
    }
  }

  // ÏöîÏùº ÌÇ§Î•º Í∏∞Î∞òÏúºÎ°ú Îã§Ïùå Ìï¥Îãπ ÏöîÏùºÏùò ÎÇ†Ïßú Í≥ÑÏÇ∞
  private getNextDateForDay(baseDate: string, dayKey: string): string {
    const dayMap = {
      'sunday': 0,
      'monday': 1,
      'tuesday': 2,
      'wednesday': 3,
      'thursday': 4,
      'friday': 5,
      'saturday': 6
    };
    
    const targetDay = dayMap[dayKey as keyof typeof dayMap];
    const base = moment(baseDate);
    const currentDay = base.day();
    
    // ÌòÑÏû¨ Ï£ºÏóêÏÑú Ìï¥Îãπ ÏöîÏùºÍπåÏßÄÏùò Ï∞®Ïù¥ Í≥ÑÏÇ∞
    let daysToAdd = targetDay - currentDay;
    if (daysToAdd < 0) {
      daysToAdd += 7; // Îã§Ïùå Ï£ºÏùò Ìï¥Îãπ ÏöîÏùº
    }
    
    return base.add(daysToAdd, 'days').format('YYYY-MM-DD');
  }

  // Î∞òÎ≥µ ÏùºÏ†ïÍ≥º Ïó∞Í≤∞Îêú ÌïôÏõê Ï†ïÎ≥¥ Ï†ÄÏû• (ÌïôÏõê Ïπ¥ÌÖåÍ≥†Î¶¨Ïù∏ Í≤ΩÏö∞)
  async createAcademyForRecurringEvent(
    academyName: string,
    subject: Academy['subject'],
    scheduleId: number
  ): Promise<number> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('Creating/finding academy:', academyName, subject, 'for schedule:', scheduleId);
      
      // ÎèôÏùºÌïú Ïä§ÏºÄÏ§ÑÏóêÏÑú ÎèôÏùºÌïú Ïù¥Î¶ÑÍ≥º Í≥ºÎ™©Ïùò ÌïôÏõêÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const existingAcademy = await db.getFirstAsync<any>(
        'SELECT * FROM academies WHERE schedule_id = ? AND name = ? AND subject = ? AND del_yn = 0',
        [scheduleId, academyName, subject]
      );
      
      if (existingAcademy) {
        console.log('Found existing academy:', existingAcademy.id);
        return existingAcademy.id;
      }
      
      // ÏÉà ÌïôÏõê ÏÉùÏÑ±
      const result = await db.runAsync(
        `INSERT INTO academies (schedule_id, name, subject, status, del_yn) VALUES (?, ?, ?, ?, ?)`,
        [scheduleId, academyName, subject, 'ÏßÑÌñâ', 0]
      );
      
      console.log('Created new academy with ID:', result.lastInsertRowId);
      return result.lastInsertRowId;
    } catch (error) {
      console.error('Error creating academy for recurring event:', error);
      throw error;
    }
  }

  // ‚úÖ Í∞úÏÑ†Îêú Ïù¥Î≤§Ìä∏ Ï°∞Ìöå (Î∞òÎ≥µ ÏùºÏ†ï ÌôïÏû• Ìè¨Ìï® + Ï†ïÏ†ú Î°úÏßÅ)
  async getEventsWithRecurring(
    scheduleId: number, 
    startDate: string, 
    endDate: string
  ): Promise<Event[]> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('üîç Loading events with recurring support...');
      
      // 1. ÏùºÎ∞ò ÏùºÏ†ï Ï°∞Ìöå
      const regularEvents = await db.getAllAsync<any>(
        `SELECT e.*, a.name as academy_name, a.subject as academy_subject
        FROM events e
        LEFT JOIN academies a ON e.academy_id = a.id AND a.del_yn = 0
        WHERE e.schedule_id = ? AND e.del_yn = 0 AND e.is_recurring = 0
        AND e.event_date BETWEEN ? AND ?
        ORDER BY e.start_time`,
        [scheduleId, startDate, endDate]
      );
      
      // 2. Î∞òÎ≥µ ÏùºÏ†ï Ï°∞Ìöå
      const recurringEvents = await db.getAllAsync<any>(
        `SELECT e.*, a.name as academy_name, a.subject as academy_subject, 
                rp.monday, rp.tuesday, rp.wednesday, rp.thursday, 
                rp.friday, rp.saturday, rp.sunday, 
                rp.start_date, rp.end_date
        FROM events e
        LEFT JOIN academies a ON e.academy_id = a.id AND a.del_yn = 0
        INNER JOIN recurring_patterns rp ON e.recurring_group_id = rp.id
        WHERE e.schedule_id = ? AND e.del_yn = 0 AND e.is_recurring = 1
        AND rp.del_yn = 0
        AND rp.start_date <= ?
        AND (rp.end_date IS NULL OR rp.end_date >= ?)`,
        [scheduleId, endDate, startDate]
      );
      
      console.log(`üìù Regular events: ${regularEvents.length}, Recurring patterns: ${recurringEvents.length}`);
      
      // 3. Î∞òÎ≥µ ÏùºÏ†ïÏùÑ ÎÇ†ÏßúÎ≥ÑÎ°ú ÌôïÏû•ÌïòÍ≥† ÏòàÏô∏ Ï†ÅÏö©
      const expandedRecurringEvents: Event[] = [];
      
      for (const recurringEvent of recurringEvents) {
        console.log(`üîÑ Processing recurring event: ${recurringEvent.title}`);
        
        // Í∏∞Î≥∏ ÎÇ†ÏßúÎì§ ÏÉùÏÑ±
        const dates = this.generateRecurringDates(recurringEvent, startDate, endDate);
        
        // Ìï¥Îãπ Î∞òÎ≥µ ÏùºÏ†ïÏùò ÏòàÏô∏Îì§ Ï°∞Ìöå
        const exceptions = await this.getRecurringExceptions(recurringEvent.id, startDate, endDate);
        const exceptionMap = new Map<string, RecurringException>();
        exceptions.forEach(ex => exceptionMap.set(ex.exception_date, ex));
        
        console.log(`üìÖ Generated ${dates.length} dates, Found ${exceptions.length} exceptions`);
        if (exceptions.length > 0) {
          console.log('üîç Exception details:', exceptions.map(ex => ({
            date: ex.exception_date,
            type: ex.exception_type,
            hasModifications: !!(ex.modified_title || ex.modified_start_time || ex.modified_end_time)
          })));
        }
        
        for (const date of dates) {
          const exception = exceptionMap.get(date);
          
          if (exception && exception.exception_type === 'cancel') {
            // Ï∑®ÏÜåÎêú ÎÇ†ÏßúÎäî Í±¥ÎÑàÎõ∞Í∏∞
            console.log(`‚ùå Skipping cancelled date: ${date}`);
            continue;
          }
          
          // Í∏∞Î≥∏ Ïù¥Î≤§Ìä∏ ÏÉùÏÑ±
          let eventForDate: Event = this.sanitizeEventData({
            id: recurringEvent.id,
            schedule_id: recurringEvent.schedule_id,
            title: recurringEvent.title,
            start_time: recurringEvent.start_time,
            end_time: recurringEvent.end_time,
            event_date: date,
            category: recurringEvent.category,
            academy_id: recurringEvent.academy_id,
            is_recurring: true,
            recurring_group_id: recurringEvent.recurring_group_id,
            created_at: recurringEvent.created_at,
            updated_at: recurringEvent.updated_at,
            del_yn: recurringEvent.del_yn,
            academy_name: recurringEvent.academy_name,
            academy_subject: recurringEvent.academy_subject,
          });
          
          // ‚úÖ ÏàòÏ†ï ÏòàÏô∏Í∞Ä ÏûàÎäî Í≤ΩÏö∞ Ï†ÅÏö© - Í∞úÏÑ†Îêú Î°úÏßÅ
          if (exception && exception.exception_type === 'modify') {
            console.log(`‚úèÔ∏è Applying exception for ${date}:`, {
              exceptionId: exception.id,
              originalData: {
                title: eventForDate.title,
                startTime: eventForDate.start_time,
                endTime: eventForDate.end_time,
                category: eventForDate.category,
                academyId: eventForDate.academy_id
              },
              modificationData: {
                title: exception.modified_title,
                startTime: exception.modified_start_time,
                endTime: exception.modified_end_time,
                category: exception.modified_category,
                academyId: exception.modified_academy_id
              }
            });
            
            // ‚úÖ null, undefined, Îπà Î¨∏ÏûêÏó¥ÏùÑ Î™®Îëê Ï≤¥ÌÅ¨ÌïòÏó¨ ÏàòÏ†ïÎêú Í∞íÎì§ Ï†ÅÏö©
            if (exception.modified_title !== null && exception.modified_title !== undefined && exception.modified_title.trim() !== '') {
              const oldTitle = eventForDate.title;
              eventForDate.title = exception.modified_title;
              console.log(`   üìù Title updated: "${oldTitle}" ‚Üí "${exception.modified_title}"`);
            } else {
              console.log(`   üìù Title unchanged: "${eventForDate.title}" (no valid modification)`);
            }
            
            if (exception.modified_start_time !== null && exception.modified_start_time !== undefined && exception.modified_start_time.trim() !== '') {
              const oldStartTime = eventForDate.start_time;
              eventForDate.start_time = exception.modified_start_time;
              console.log(`   ‚è∞ Start time updated: "${oldStartTime}" ‚Üí "${exception.modified_start_time}"`);
            } else {
              console.log(`   ‚è∞ Start time unchanged: "${eventForDate.start_time}" (no valid modification)`);
            }
            
            if (exception.modified_end_time !== null && exception.modified_end_time !== undefined && exception.modified_end_time.trim() !== '') {
              const oldEndTime = eventForDate.end_time;
              eventForDate.end_time = exception.modified_end_time;
              console.log(`   ‚è∞ End time updated: "${oldEndTime}" ‚Üí "${exception.modified_end_time}"`);
            } else {
              console.log(`   ‚è∞ End time unchanged: "${eventForDate.end_time}" (no valid modification)`);
            }
            
            if (exception.modified_category !== null && exception.modified_category !== undefined && exception.modified_category.trim() !== '') {
              const oldCategory = eventForDate.category;
              eventForDate.category = exception.modified_category;
              console.log(`   üìÇ Category updated: "${oldCategory}" ‚Üí "${exception.modified_category}"`);
            } else {
              console.log(`   üìÇ Category unchanged: "${eventForDate.category}" (no valid modification)`);
            }
            
            if (exception.modified_academy_id !== null && exception.modified_academy_id !== undefined) {
              const previousAcademyId = eventForDate.academy_id;
              eventForDate.academy_id = exception.modified_academy_id;
              console.log(`   üè´ Academy ID updated: ${previousAcademyId} ‚Üí ${exception.modified_academy_id}`);
              
              // ‚úÖ ÏàòÏ†ïÎêú ÌïôÏõê Ï†ïÎ≥¥ Î°úÎìú - ÏóêÎü¨ Ï≤òÎ¶¨ Í∞ïÌôî
              try {
                const modifiedAcademy = await this.getAcademyById(exception.modified_academy_id);
                if (modifiedAcademy) {
                  (eventForDate as any).academy_name = modifiedAcademy.name;
                  (eventForDate as any).academy_subject = modifiedAcademy.subject;
                  console.log(`   ‚úÖ Academy info loaded: ${modifiedAcademy.name} (${modifiedAcademy.subject})`);
                } else {
                  console.warn(`   ‚ö†Ô∏è Academy ${exception.modified_academy_id} not found, keeping original info`);
                  // ÏõêÎ≥∏ ÌïôÏõê Ï†ïÎ≥¥ Ïú†ÏßÄ
                  (eventForDate as any).academy_name = recurringEvent.academy_name;
                  (eventForDate as any).academy_subject = recurringEvent.academy_subject;
                }
              } catch (academyError) {
                console.error(`   ‚ùå Failed to load modified academy info for ID ${exception.modified_academy_id}:`, academyError);
                // ÏóêÎü¨ Î∞úÏÉù Ïãú ÏõêÎ≥∏ ÌïôÏõê Ï†ïÎ≥¥ Ïú†ÏßÄ
                (eventForDate as any).academy_name = recurringEvent.academy_name;
                (eventForDate as any).academy_subject = recurringEvent.academy_subject;
              }
            } else {
              console.log(`   üè´ Academy unchanged: ID ${eventForDate.academy_id} (no valid modification)`);
            }
            
            // ÏòàÏô∏ IDÎ•º ÌäπÎ≥ÑÌûà ÌëúÏãú (UIÏóêÏÑú Íµ¨Î∂ÑÏö©)
            (eventForDate as any).exception_id = exception.id;
            (eventForDate as any).exception_type = exception.exception_type;
            
            console.log(`‚úÖ Exception applied successfully for ${date}:`, {
              finalData: {
                title: eventForDate.title,
                startTime: eventForDate.start_time,
                endTime: eventForDate.end_time,
                category: eventForDate.category,
                academyId: eventForDate.academy_id
              },
              exceptionId: (eventForDate as any).exception_id
            });
          }
          
          expandedRecurringEvents.push(eventForDate);
        }
      }
      
      // 4. Î™®Îì† Ïù¥Î≤§Ìä∏ Ìï©ÏπòÍ∏∞
      const sanitizedRegularEvents = this.sanitizeEventArray(regularEvents);
      const allEvents = [...sanitizedRegularEvents, ...expandedRecurringEvents];
      
      console.log(`üìã Final event summary:`, {
        regular: sanitizedRegularEvents.length,
        recurring: expandedRecurringEvents.length,
        total: allEvents.length,
        exceptions: allEvents.filter(e => !!(e as any).exception_id).length
      });
      
      // 5. Ï§ëÎ≥µ Ï†úÍ±∞ Î∞è Ï†ïÎ†¨
      const uniqueEvents = this.removeDuplicateEvents(allEvents);
      
      return uniqueEvents.sort((a, b) => {
        if (a.event_date !== b.event_date) {
          return (a.event_date || '').localeCompare(b.event_date || '');
        }
        return a.start_time.localeCompare(b.start_time);
      });
      
    } catch (error) {
      console.error('‚ùå Error getting events with recurring:', error);
      throw error;
    }
  }

  // ‚úÖ Ï§ëÎ≥µ Ïù¥Î≤§Ìä∏ Ï†úÍ±∞ Î©îÏÑúÎìú Ï∂îÍ∞Ä
  private removeDuplicateEvents(events: Event[]): Event[] {
    const uniqueEvents = new Map<string, Event>();
    
    for (const event of events) {
      // Ï§ëÎ≥µ ÌÇ§ ÏÉùÏÑ±: ÎÇ†Ïßú_ÏãúÏûëÏãúÍ∞Ñ_Ï†úÎ™©_Ïπ¥ÌÖåÍ≥†Î¶¨
      const key = `${event.event_date}_${event.start_time}_${event.title}_${event.category}`;
      
      // Ïù¥ÎØ∏ ÏûàÎäî Ïù¥Î≤§Ìä∏Ïù∏ Í≤ΩÏö∞, ÏòàÏô∏Í∞Ä ÏûàÎäî Í≤ÉÏùÑ Ïö∞ÏÑ†
      const existing = uniqueEvents.get(key);
      if (existing) {
        const hasException = !!(event as any).exception_id;
        const existingHasException = !!(existing as any).exception_id;
        
        if (hasException && !existingHasException) {
          // ÏÉà Ïù¥Î≤§Ìä∏Í∞Ä ÏòàÏô∏Í≥† Í∏∞Ï°¥Ïù¥ ÏùºÎ∞òÏù¥Î©¥ ÏÉà Í≤ÉÏùÑ ÏÇ¨Ïö©
          uniqueEvents.set(key, event);
          console.log(`üîÑ Replaced regular event with exception for ${key}`);
        }
        // Í∑∏ Ïô∏Ïùò Í≤ΩÏö∞Îäî Í∏∞Ï°¥ Í≤ÉÏùÑ Ïú†ÏßÄ
      } else {
        uniqueEvents.set(key, event);
      }
    }
    
    return Array.from(uniqueEvents.values());
  }

  // Î∞òÎ≥µ ÏùºÏ†ïÏùò ÎÇ†ÏßúÎì§ ÏÉùÏÑ±
  private generateRecurringDates(
    recurringEvent: any,
    startDate: string,
    endDate: string
  ): string[] {
    const dates: string[] = [];
    
    try {
      const start = new Date(startDate);
      const end = new Date(endDate);
      const patternStart = new Date(recurringEvent.start_date);
      const patternEnd = recurringEvent.end_date ? new Date(recurringEvent.end_date) : null;
      
      // ÏãúÏûëÏùºÏùÑ Ï°∞Ï†ï (Ìå®ÌÑ¥ ÏãúÏûëÏùº Ïù¥ÌõÑÎ∂ÄÌÑ∞)
      let current = new Date(Math.max(start.getTime(), patternStart.getTime()));
      
      while (current <= end) {
        const dayOfWeek = current.getDay(); // 0=ÏùºÏöîÏùº, 1=ÏõîÏöîÏùº, ..., 6=ÌÜ†ÏöîÏùº
        let shouldInclude = false;
        
        // ÏöîÏùº ÌôïÏù∏ (‚úÖ Boolean ÌÉÄÏûÖ Ï†ïÏ†ú)
        switch (dayOfWeek) {
          case 0: shouldInclude = Boolean(recurringEvent.sunday); break;
          case 1: shouldInclude = Boolean(recurringEvent.monday); break;
          case 2: shouldInclude = Boolean(recurringEvent.tuesday); break;
          case 3: shouldInclude = Boolean(recurringEvent.wednesday); break;
          case 4: shouldInclude = Boolean(recurringEvent.thursday); break;
          case 5: shouldInclude = Boolean(recurringEvent.friday); break;
          case 6: shouldInclude = Boolean(recurringEvent.saturday); break;
        }
        
        // Ìå®ÌÑ¥ Ï¢ÖÎ£åÏùº ÌôïÏù∏
        if (patternEnd && current > patternEnd) {
          shouldInclude = false;
        }
        
        if (shouldInclude) {
          const dateStr = current.toISOString().split('T')[0]; // YYYY-MM-DD ÌòïÏãù
          dates.push(dateStr);
        }
        
        // Îã§Ïùå ÎÇ†Î°ú Ïù¥Îèô
        current.setDate(current.getDate() + 1);
      }
      
    } catch (error) {
      console.error('Error generating recurring dates:', error);
    }
    
    return dates;
  }

  // Î∞òÎ≥µ Ìå®ÌÑ¥ ÏóÖÎç∞Ïù¥Ìä∏
  async updateRecurringPattern(pattern: RecurringPattern): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      await db.runAsync(
        `UPDATE recurring_patterns SET 
        monday = ?, tuesday = ?, wednesday = ?, thursday = ?,
        friday = ?, saturday = ?, sunday = ?,
        start_date = ?, end_date = ?, updated_at = CURRENT_TIMESTAMP
        WHERE id = ?`,
        [
          pattern.monday ? 1 : 0,
          pattern.tuesday ? 1 : 0,
          pattern.wednesday ? 1 : 0,
          pattern.thursday ? 1 : 0,
          pattern.friday ? 1 : 0,
          pattern.saturday ? 1 : 0,
          pattern.sunday ? 1 : 0,
          pattern.start_date,
          pattern.end_date ?? null,
          pattern.id
        ]
      );
    } catch (error) {
      console.error('Error updating recurring pattern:', error);
      throw error;
    }
  }

  // Î∞òÎ≥µ ÏùºÏ†ï ÏÇ≠Ï†ú (Ìå®ÌÑ¥Í≥º Ïó∞Í≤∞Îêú Î™®Îì† Ïù¥Î≤§Ìä∏ ÏÇ≠Ï†ú)
  async deleteRecurringEvent(eventId: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('Deleting recurring event:', eventId);
      
      // Ïù¥Î≤§Ìä∏ Ï†ïÎ≥¥ Ï°∞Ìöå (‚úÖ Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
      const eventResult = await db.getFirstAsync<any>(
        'SELECT * FROM events WHERE id = ? AND del_yn = 0',
        [eventId]
      );
      
      if (!eventResult) {
        throw new Error('Event not found');
      }
      
      const event = this.sanitizeEventData(eventResult);
      
      console.log('Found event to delete:', event);
      
      if (event.is_recurring && event.recurring_group_id) {
        console.log('Deleting recurring pattern:', event.recurring_group_id);
        
        // Î∞òÎ≥µ Ìå®ÌÑ¥ ÏÇ≠Ï†ú
        await db.runAsync(
          'UPDATE recurring_patterns SET del_yn = 1 WHERE id = ?',
          [event.recurring_group_id]
        );
        
        // Ïó∞Í≤∞Îêú Î™®Îì† Ïù¥Î≤§Ìä∏ ÏÇ≠Ï†ú
        await db.runAsync(
          'UPDATE events SET del_yn = 1 WHERE recurring_group_id = ?',
          [event.recurring_group_id]
        );
        
        console.log('Recurring event and pattern deleted');
      } else {
        // Îã®Ïùº Ïù¥Î≤§Ìä∏ ÏÇ≠Ï†ú
        await db.runAsync('UPDATE events SET del_yn = 1 WHERE id = ?', [eventId]);
        console.log('Single event deleted');
      }
    } catch (error) {
      console.error('Error deleting recurring event:', error);
      throw error;
    }
  }

  // Î∞òÎ≥µ Ìå®ÌÑ¥ Í¥ÄÎ¶¨
  async createRecurringPattern(pattern: Omit<RecurringPattern, 'id' | 'created_at'>): Promise<number> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('Creating recurring pattern:', pattern);
      
      const result = await db.runAsync(
        `INSERT INTO recurring_patterns (
          monday, tuesday, wednesday, thursday, friday, saturday, sunday,
          start_date, end_date
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          pattern.monday ? 1 : 0, 
          pattern.tuesday ? 1 : 0, 
          pattern.wednesday ? 1 : 0, 
          pattern.thursday ? 1 : 0, 
          pattern.friday ? 1 : 0, 
          pattern.saturday ? 1 : 0, 
          pattern.sunday ? 1 : 0, 
          pattern.start_date, 
          pattern.end_date ?? null
        ]
      );
      
      console.log('Recurring pattern created with ID:', result.lastInsertRowId);
      return result.lastInsertRowId;
    } catch (error) {
      console.error('Error creating recurring pattern:', error);
      throw error;
    }
  }

  async testRecurringRetrieval(scheduleId: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('üß™ === Testing Recurring Event Retrieval ===');
      
      // 1. Ï†ÄÏû•Îêú Î∞òÎ≥µ Ïù¥Î≤§Ìä∏ ÌôïÏù∏
      const recurringEvents = await db.getAllAsync(`
        SELECT * FROM events WHERE is_recurring = 1 AND del_yn = 0
      `);
      console.log('üß™ Stored recurring events:', recurringEvents);
      
      // 2. Î∞òÎ≥µ Ìå®ÌÑ¥ ÌôïÏù∏
      const patterns = await db.getAllAsync(`
        SELECT * FROM recurring_patterns WHERE del_yn = 0
      `);
      console.log('üß™ Stored patterns:', patterns);
      
      // 3. Ï°∞Ïù∏Îêú Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
      const joinedData = await db.getAllAsync(`
        SELECT e.*, 
               rp.monday, rp.tuesday, rp.wednesday, rp.thursday, 
               rp.friday, rp.saturday, rp.sunday, 
               rp.start_date, rp.end_date
        FROM events e
        INNER JOIN recurring_patterns rp ON e.recurring_group_id = rp.id
        WHERE e.schedule_id = ? AND e.del_yn = 0 AND e.is_recurring = 1 AND rp.del_yn = 0
      `, [scheduleId]);
      console.log('üß™ Joined recurring data:', joinedData);
      
      // 4. ÌäπÏ†ï Í∏∞Í∞ÑÏúºÎ°ú Ïù¥Î≤§Ìä∏ Ï°∞Ìöå ÌÖåÏä§Ìä∏
      const testStartDate = '2025-05-26'; // ÏõîÏöîÏùº
      const testEndDate = '2025-06-01';   // ÏùºÏöîÏùº
      
      console.log(`üß™ Testing retrieval for period: ${testStartDate} to ${testEndDate}`);
      
      const retrievedEvents = await this.getEventsWithRecurring(
        scheduleId, 
        testStartDate, 
        testEndDate
      );
      console.log('üß™ Retrieved events with recurring:', retrievedEvents);
      
    } catch (error) {
      console.error('üß™ Test retrieval error:', error);
    }
  }

  // ‚úÖ Î∞òÎ≥µ Ìå®ÌÑ¥ Ï°∞Ìöå Î©îÏÑúÎìú (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getRecurringPattern(id: number): Promise<RecurringPattern | null> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getFirstAsync<any>(
        'SELECT * FROM recurring_patterns WHERE id = ? AND del_yn = 0',
        [id]
      );
      return result ? this.sanitizeRecurringPatternData(result) : null;
    } catch (error) {
      console.error('Error getting recurring pattern:', error);
      throw error;
    }
  }

  // ‚úÖ ÌïôÏõê IDÎ°ú ÌïôÏõê Ï†ïÎ≥¥ Ï°∞Ìöå Î©îÏÑúÎìú (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getAcademyById(id: number): Promise<Academy | null> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getFirstAsync<any>(
        'SELECT * FROM academies WHERE id = ? AND del_yn = 0',
        [id]
      );
      return result ? this.sanitizeAcademyData(result) : null;
    } catch (error) {
      console.error('Error getting academy by id:', error);
      throw error;
    }
  }

  // ‚úÖ ÌäπÏ†ï ÏùºÏ†ïÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getEventDetails(id: number): Promise<(Event & { academy_name?: string; academy_subject?: string }) | null> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getFirstAsync<any>(
        `SELECT e.*, a.name as academy_name, a.subject as academy_subject
        FROM events e
        LEFT JOIN academies a ON e.academy_id = a.id AND a.del_yn = 0
        WHERE e.id = ? AND e.del_yn = 0`,
        [id]
      );
      return result ? this.sanitizeEventData(result) : null;
    } catch (error) {
      console.error('Error getting event details:', error);
      throw error;
    }
  }

  // ÏòàÏô∏ ÏÉùÏÑ±
  async createRecurringException(exception: Omit<RecurringException, 'id' | 'created_at' | 'updated_at'>): Promise<number> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('üîÑ Creating recurring exception with full data:', {
        eventId: exception.recurring_event_id,
        date: exception.exception_date,
        type: exception.exception_type,
        modifications: {
          title: exception.modified_title,
          startTime: exception.modified_start_time,
          endTime: exception.modified_end_time,
          category: exception.modified_category,
          academyId: exception.modified_academy_id
        },
        hasModifications: !!(
          exception.modified_title || 
          exception.modified_start_time || 
          exception.modified_end_time || 
          exception.modified_category || 
          exception.modified_academy_id
        )
      });
      
      // ‚úÖ Í∏∞Ï°¥ ÏòàÏô∏Í∞Ä ÏûàÎäîÏßÄ Î®ºÏ†Ä ÌôïÏù∏
      const existingException = await db.getFirstAsync<any>(
        'SELECT * FROM recurring_exceptions WHERE recurring_event_id = ? AND exception_date = ? AND del_yn = 0',
        [exception.recurring_event_id, exception.exception_date]
      );
      
      if (existingException) {
        console.log('‚ö†Ô∏è Exception already exists, updating instead of creating');
        console.log('üìä Existing exception data:', existingException);
        
        // Í∏∞Ï°¥ ÏòàÏô∏ ÏóÖÎç∞Ïù¥Ìä∏
        await db.runAsync(
          `UPDATE recurring_exceptions SET 
          exception_type = ?, modified_title = ?, modified_start_time = ?, 
          modified_end_time = ?, modified_category = ?, modified_academy_id = ?,
          updated_at = CURRENT_TIMESTAMP
          WHERE id = ?`,
          [
            exception.exception_type,
            exception.modified_title ?? null,
            exception.modified_start_time ?? null,
            exception.modified_end_time ?? null,
            exception.modified_category ?? null,
            exception.modified_academy_id ?? null,
            existingException.id
          ]
        );
        
        console.log('‚úÖ Exception updated successfully');
        
        // ÏóÖÎç∞Ïù¥Ìä∏Îêú Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
        const updatedException = await db.getFirstAsync<any>(
          'SELECT * FROM recurring_exceptions WHERE id = ?',
          [existingException.id]
        );
        console.log('üìä Updated exception data:', updatedException);
        
        return existingException.id;
      }
      
      // ÏÉà ÏòàÏô∏ ÏÉùÏÑ±
      const result = await db.runAsync(
        `INSERT INTO recurring_exceptions (
          recurring_event_id, exception_date, exception_type,
          modified_title, modified_start_time, modified_end_time,
          modified_category, modified_academy_id
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          exception.recurring_event_id,
          exception.exception_date,
          exception.exception_type,
          exception.modified_title ?? null,
          exception.modified_start_time ?? null,
          exception.modified_end_time ?? null,
          exception.modified_category ?? null,
          exception.modified_academy_id ?? null,
        ]
      );
      
      console.log('‚úÖ Exception created with ID:', result.lastInsertRowId);
      
      // ÏÉùÏÑ±Îêú Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
      const createdException = await db.getFirstAsync<any>(
        'SELECT * FROM recurring_exceptions WHERE id = ?',
        [result.lastInsertRowId]
      );
      console.log('üìä Created exception data:', createdException);
      
      return result.lastInsertRowId;
    } catch (error) {
      console.error('‚ùå Error creating recurring exception:', error);
      throw error;
    }
  }

  // ‚úÖ ÏòàÏô∏ Ï°∞Ìöå (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getRecurringExceptions(eventId: number, startDate: string, endDate: string): Promise<RecurringException[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<any>(
        `SELECT * FROM recurring_exceptions 
        WHERE recurring_event_id = ? 
          AND exception_date BETWEEN ? AND ? 
          AND del_yn = 0
        ORDER BY exception_date`,
        [eventId, startDate, endDate]
      );
      return result.map(item => this.sanitizeRecurringExceptionData(item));
    } catch (error) {
      console.error('Error getting recurring exceptions:', error);
      throw error;
    }
  }

  // ÏòàÏô∏ ÏàòÏ†ï
  async updateRecurringException(exception: RecurringException): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('üîÑ Updating recurring exception:', {
        id: exception.id,
        eventId: exception.recurring_event_id,
        date: exception.exception_date,
        type: exception.exception_type,
        modifications: {
          title: exception.modified_title,
          startTime: exception.modified_start_time,
          endTime: exception.modified_end_time,
          category: exception.modified_category,
          academyId: exception.modified_academy_id
        }
      });
      
      await db.runAsync(
        `UPDATE recurring_exceptions SET 
        exception_type = ?, modified_title = ?, modified_start_time = ?, 
        modified_end_time = ?, modified_category = ?, modified_academy_id = ?,
        updated_at = CURRENT_TIMESTAMP
        WHERE id = ?`,
        [
          exception.exception_type,
          exception.modified_title ?? null,
          exception.modified_start_time ?? null,
          exception.modified_end_time ?? null,
          exception.modified_category ?? null,
          exception.modified_academy_id ?? null,
          exception.id
        ]
      );
      
      console.log('‚úÖ Exception updated successfully');
    } catch (error) {
      console.error('‚ùå Error updating recurring exception:', error);
      throw error;
    }
  }

  // ÏòàÏô∏ ÏÇ≠Ï†ú
  async deleteRecurringException(id: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      await db.runAsync('UPDATE recurring_exceptions SET del_yn = 1 WHERE id = ?', [id]);
    } catch (error) {
      console.error('Error deleting recurring exception:', error);
      throw error;
    }
  }

  // Í≥µÌú¥Ïùº Ï†ÄÏû•
  async saveHolidays(holidays: Omit<Holiday, 'id' | 'created_at' | 'updated_at'>[]): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      // Ìä∏ÎûúÏû≠ÏÖòÏúºÎ°ú ÏùºÍ¥Ñ Ï†ÄÏû•
      await db.execAsync('BEGIN TRANSACTION');
      
      for (const holiday of holidays) {
        await db.runAsync(
          `INSERT OR REPLACE INTO holidays (
            date, name, is_holiday, year, month, day, updated_at
          ) VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
          [
            holiday.date,
            holiday.name,
            holiday.is_holiday ? 1 : 0,
            holiday.year,
            holiday.month,
            holiday.day
          ]
        );
      }
      
      await db.execAsync('COMMIT');
      console.log(`‚úÖ Saved ${holidays.length} holidays to database`);
    } catch (error) {
      const db = await this.ensureDbConnection();
      await db.execAsync('ROLLBACK');
      console.error('Error saving holidays:', error);
      throw error;
    }
  }

  // ‚úÖ ÌäπÏ†ï Ïó∞ÎèÑÏùò Í≥µÌú¥Ïùº Ï°∞Ìöå (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getHolidaysByYear(year: number): Promise<Holiday[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<any>(
        'SELECT * FROM holidays WHERE year = ? AND del_yn = 0 ORDER BY date',
        [year]
      );
      return this.sanitizeHolidayArray(result);
    } catch (error) {
      console.error('Error getting holidays by year:', error);
      throw error;
    }
  }

  // ‚úÖ ÌäπÏ†ï ÎÇ†ÏßúÏùò Í≥µÌú¥Ïùº Ï°∞Ìöå (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getHolidayByDate(date: string): Promise<Holiday | null> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getFirstAsync<any>(
        'SELECT * FROM holidays WHERE date = ? AND del_yn = 0',
        [date]
      );
      return result ? this.sanitizeHolidayData(result) : null;
    } catch (error) {
      console.error('Error getting holiday by date:', error);
      throw error;
    }
  }

  // ‚úÖ ÌäπÏ†ï Í∏∞Í∞ÑÏùò Í≥µÌú¥Ïùº Ï°∞Ìöå (Ï†ïÏ†ú Î°úÏßÅ Ï†ÅÏö©)
  async getHolidaysInRange(startDate: string, endDate: string): Promise<Holiday[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<any>(
        'SELECT * FROM holidays WHERE date BETWEEN ? AND ? AND del_yn = 0 ORDER BY date',
        [startDate, endDate]
      );
      return this.sanitizeHolidayArray(result);
    } catch (error) {
      console.error('Error getting holidays in range:', error);
      throw error;
    }
  }

  // Í≥µÌú¥Ïùº Îç∞Ïù¥ÌÑ∞ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
  async hasHolidaysForYear(year: number): Promise<boolean> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getFirstAsync<{ count: number }>(
        'SELECT COUNT(*) as count FROM holidays WHERE year = ? AND del_yn = 0',
        [year]
      );
      const count = result?.count || 0;
      console.log(`üìä Holidays in DB for year ${year}: ${count} records`);
      return count > 0;
    } catch (error) {
      console.error('Error checking holidays existence:', error);
      return false;
    }
  }

  // Í≥µÌú¥Ïùº Ï∫êÏãú Î¨¥Ìö®Ìôî (Ïû¨Îã§Ïö¥Î°úÎìú Ïãú ÏÇ¨Ïö©)
  async clearHolidaysForYear(year: number): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      await db.runAsync(
        'UPDATE holidays SET del_yn = 1 WHERE year = ?',
        [year]
      );
      console.log(`‚úÖ Cleared holidays for year ${year}`);
    } catch (error) {
      console.error('Error clearing holidays:', error);
      throw error;
    }
  }

  // üß™ Í≥µÌú¥Ïùº ÎîîÎ≤ÑÍπÖÏö© Î©îÏÑúÎìú
  async debugHolidayData(): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log('üß™ === Holiday Database Debug Info ===');
      
      // 1. Ï†ÑÏ≤¥ Í≥µÌú¥Ïùº Í∞úÏàò
      const totalCount = await db.getFirstAsync<{ count: number }>(
        'SELECT COUNT(*) as count FROM holidays WHERE del_yn = 0'
      );
      console.log(`üß™ Total holidays in DB: ${totalCount?.count || 0}`);
      
      // 2. Ïó∞ÎèÑÎ≥Ñ Í≥µÌú¥Ïùº Í∞úÏàò
      const yearCounts = await db.getAllAsync<{ year: number; count: number }>(
        'SELECT year, COUNT(*) as count FROM holidays WHERE del_yn = 0 GROUP BY year ORDER BY year'
      );
      console.log('üß™ Holidays by year:');
      yearCounts.forEach(({ year, count }) => {
        console.log(`   ${year}: ${count} holidays`);
      });
      
      // 3. ÌòÑÏû¨ Ïó∞ÎèÑ Í≥µÌú¥Ïùº ÏÉÅÏÑ∏ Î™©Î°ù
      const currentYear = new Date().getFullYear();
      const currentYearHolidays = await this.getHolidaysByYear(currentYear);
      
      console.log(`üß™ ${currentYear} Holiday Details:`);
      currentYearHolidays.forEach(holiday => {
        console.log(`   üìÖ ${holiday.date}: ${holiday.name} (Holiday: ${holiday.is_holiday})`);
      });
      
      console.log('üß™ === End Holiday Debug Info ===');
      
    } catch (error) {
      console.error('üß™ Error in holiday debug:', error);
    }
  }

  // üß™ ÌäπÏ†ï ÎÇ†Ïßú Î≤îÏúÑÏùò Í≥µÌú¥Ïùº ÎîîÎ≤ÑÍπÖ
  async debugHolidaysInRange(startDate: string, endDate: string): Promise<void> {
    try {
      const db = await this.ensureDbConnection();
      
      console.log(`üß™ === Holiday Debug for ${startDate} ~ ${endDate} ===`);
      
      const holidays = await this.getHolidaysInRange(startDate, endDate);
      
      console.log(`üß™ Found ${holidays.length} holidays in range:`);
      holidays.forEach(holiday => {
        console.log(`   üìÖ ${holiday.date}: ${holiday.name} (Holiday: ${holiday.is_holiday})`);
      });
      
      if (holidays.length === 0) {
        console.log('üß™ ‚ö†Ô∏è No holidays found in this date range');
      }
      
      console.log('üß™ === End Range Debug ===');
      
    } catch (error) {
      console.error('üß™ Error in range holiday debug:', error);
    }
  }

  // ÌïôÏõêÎ≥Ñ Ï¥ù ÏßÄÏ∂ú Í∏àÏï° ÌÜµÍ≥Ñ
  async getAcademyExpenseStats(): Promise<AcademyExpenseStats[]> {
    try {
      const db = await this.ensureDbConnection();
      const result = await db.getAllAsync<AcademyExpenseStats>(
        `SELECT 
          a.id as academy_id,
          a.name as academy_name,
          a.subject,
          a.monthly_fee,
          a.payment_cycle,
          CASE 
            WHEN a.end_month IS NULL THEN 
              CAST((julianday('now') - julianday(a.start_month || '-01')) / 30.44 AS INTEGER) + 1
            ELSE 
              CAST((julianday(a.end_month || '-01') - julianday(a.start_month || '-01')) / 30.44 AS INTEGER) + 1
          END as months_count,
          CASE 
            WHEN a.monthly_fee IS NOT NULL AND a.payment_cycle IS NOT NULL THEN
              CASE 
                WHEN a.end_month IS NULL THEN 
                  (CAST((julianday('now') - julianday(a.start_month || '-01')) / 30.44 AS INTEGER) + 1) * (a.monthly_fee / a.payment_cycle)
                ELSE 
                  (CAST((julianday(a.end_month || '-01') - julianday(a.start_month || '-01')) / 30.44 AS INTEGER) + 1) * (a.monthly_fee / a.payment_cycle)
              END
            ELSE 0
          END as total_expense
        FROM academies a
        WHERE a.del_yn = 0 AND a.start_month IS NOT NULL
        ORDER BY total_expense DESC, a.subject, a.name`
      );
      return result;
    } catch (error) {
      console.error('Error getting academy expense stats:', error);
      throw error;
    }
  }

  // ÏõîÎ≥Ñ ÏßÄÏ∂ú ÌÜµÍ≥Ñ
  async getMonthlyExpenseStats(year: number, month: number): Promise<MonthlyExpenseStats[]> {
    try {
      const db = await this.ensureDbConnection();
      
      // ÎØ∏Îûò Îã¨Ïù∏ Í≤ΩÏö∞ Îπà Î∞∞Ïó¥ Î∞òÌôò
      const now = new Date();
      const currentYear = now.getFullYear();
      const currentMonth = now.getMonth() + 1;
      
      if (year > currentYear || (year === currentYear && month > currentMonth)) {
        console.log(`üìä Future month requested: ${year}-${month}, returning empty data`);
        return [];
      }
      
      console.log(`üìä Calculating expenses for ${year}-${month}`);
      
      // Ìï¥Îãπ ÏõîÏùò Î™®Îì† ÌïôÏõê Ï°∞Ìöå
      const academies = await db.getAllAsync<any>(
        `SELECT 
          id, name, subject, monthly_fee, payment_cycle, payment_method,
          payment_day, start_month, end_month, status
        FROM academies 
        WHERE del_yn = 0 
          AND monthly_fee IS NOT NULL 
          AND payment_cycle IS NOT NULL
          AND payment_day IS NOT NULL`
      );
      
      console.log(`üìä Found ${academies.length} academies with payment info`);
      
      const subjectExpenses = new Map<string, { total_expense: number; academy_count: number }>();
      
      for (const academy of academies) {
        const shouldInclude = this.shouldIncludeAcademyInMonth(academy, year, month);
        
        if (shouldInclude) {
          const monthlyAmount = academy.monthly_fee / academy.payment_cycle;
          const subject = academy.subject || 'Í∏∞ÌÉÄ';
          
          console.log(`üìä Including ${academy.name} (${subject}): ${monthlyAmount}Ïõê`);
          
          const current = subjectExpenses.get(subject) || { total_expense: 0, academy_count: 0 };
          current.total_expense += monthlyAmount;
          current.academy_count += 1;
          subjectExpenses.set(subject, current);
        } else {
          console.log(`üìä Excluding ${academy.name}: payment logic`);
        }
      }
      
      // Í≤∞Í≥º Î≥ÄÌôò
      const result: MonthlyExpenseStats[] = Array.from(subjectExpenses.entries())
        .map(([subject, data]) => ({
          subject,
          total_expense: Math.round(data.total_expense),
          academy_count: data.academy_count
        }))
        .sort((a, b) => b.total_expense - a.total_expense);
      
      console.log(`üìä Final monthly expense stats:`, result);
      return result;
    } catch (error) {
      console.error('Error getting monthly expense stats:', error);
      throw error;
    }
  }

  // ÌäπÏ†ï ÏõîÏóê ÌïôÏõêÎπÑÍ∞Ä Ìè¨Ìï®ÎêòÏñ¥Ïïº ÌïòÎäîÏßÄ ÌåêÎã®ÌïòÎäî Ìó¨Ìçº Î©îÏÑúÎìú
  private shouldIncludeAcademyInMonth(academy: any, targetYear: number, targetMonth: number): boolean {
    try {
      const { start_month, end_month, payment_day, payment_cycle } = academy;
      
      // 1. ÏãúÏûëÏõî ÌôïÏù∏
      if (!start_month) return false;
      
      const [startYear, startMonth] = start_month.split('-').map(Number);
      const startDate = new Date(startYear, startMonth - 1, 1);
      const targetDate = new Date(targetYear, targetMonth - 1, 1);
      
      // ÏãúÏûëÏõîÎ≥¥Îã§ Ïù¥Ï†ÑÏù¥Î©¥ Ï†úÏô∏
      if (targetDate < startDate) {
        return false;
      }
      
      // 2. Ï¢ÖÎ£åÏõîÍ≥º Í≤∞Ï†úÏùº ÌôïÏù∏
      if (end_month) {
        const [endYear, endMonth] = end_month.split('-').map(Number);
        const endDate = new Date(endYear, endMonth - 1, 1);
        
        // Ï¢ÖÎ£åÏõîÎ≥¥Îã§ Ïù¥ÌõÑÎ©¥ Ï†úÏô∏
        if (targetDate > endDate) {
          return false;
        }
        
        // Ï¢ÖÎ£åÏõîÍ≥º Í∞ôÏùÄ Îã¨Ïù∏ Í≤ΩÏö∞, Í≤∞Ï†úÏùº ÌôïÏù∏
        if (targetYear === endYear && targetMonth === endMonth) {
          // Í≤∞Ï†ú Ï£ºÍ∏∞Î≥Ñ Í≤∞Ï†úÏùº Í≥ÑÏÇ∞
          const paymentDates = this.getPaymentDatesForMonth(targetYear, targetMonth, payment_day, payment_cycle, startYear, startMonth);
          
          // Ìï¥Îãπ ÏõîÏóê Í≤∞Ï†úÏùºÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
          const hasPaymentInMonth = paymentDates.length > 0;
          
          if (!hasPaymentInMonth) {
            return false; // Ìï¥Îãπ ÏõîÏóê Í≤∞Ï†úÏùºÏù¥ ÏóÜÏúºÎ©¥ Ï†úÏô∏
          }
          
          console.log(`üìä Payment check for ${academy.name}: payment_day=${payment_day}, end_month=${end_month}`);
          
          // Ï§ëÎã®ÏõîÏùò Í≤ΩÏö∞ Ìï¥Îãπ ÏõîÏóê Í≤∞Ï†úÍ∞Ä Ïù¥Î£®Ïñ¥Ï°åÎäîÏßÄ ÌôïÏù∏ÌïòÏó¨ Ìè¨Ìï® Ïó¨Î∂Ä Í≤∞Ï†ï
          // ÌòÑÏû¨Îäî Í∞ÑÎã®ÌïòÍ≤å Ï§ëÎã®ÏõîÎèÑ Ìè¨Ìï®ÌïòÎäî Í≤ÉÏúºÎ°ú Ï≤òÎ¶¨ (Ïã§Ï†ú Ïï±ÏóêÏÑúÎäî Ï†ïÌôïÌïú Ï§ëÎã®ÏùºÏù¥ ÌïÑÏöî)
          return true;
        }
      }
      
      // 3. Í≤∞Ï†ú Ï£ºÍ∏∞Ïóê Îî∞Î•∏ Ìï¥Îãπ Ïõî Í≤∞Ï†ú Ïó¨Î∂Ä ÌôïÏù∏
      const paymentDates = this.getPaymentDatesForMonth(targetYear, targetMonth, payment_day, payment_cycle, startYear, startMonth);
      return paymentDates.length > 0;
      
    } catch (error) {
      console.error('Error checking academy inclusion:', error);
      return false;
    }
  }

  // ÌäπÏ†ï ÏõîÏóê Í≤∞Ï†úÏùºÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÎäî Ìó¨Ìçº Î©îÏÑúÎìú
  private getPaymentDatesForMonth(
    targetYear: number, 
    targetMonth: number, 
    paymentDay: number, 
    paymentCycle: number,
    startYear: number,
    startMonth: number
  ): number[] {
    try {
      const paymentDates: number[] = [];
      
      // ÏãúÏûëÏõîÎ∂ÄÌÑ∞ ÌòÑÏû¨ÍπåÏßÄ Í≤∞Ï†ú Ï£ºÍ∏∞ Í≥ÑÏÇ∞
      const startDate = new Date(startYear, startMonth - 1, 1);
      const targetDate = new Date(targetYear, targetMonth - 1, 1);
      
      // ÏãúÏûëÏõîÎ∂ÄÌÑ∞ ÎåÄÏÉÅÏõîÍπåÏßÄÏùò Í∞úÏõî Ïàò
      const monthsDiff = (targetYear - startYear) * 12 + (targetMonth - startMonth);
      
      // Í≤∞Ï†ú Ï£ºÍ∏∞Î≥ÑÎ°ú Ìï¥Îãπ ÏõîÏóê Í≤∞Ï†úÏùºÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      if (monthsDiff >= 0 && monthsDiff % paymentCycle === 0) {
        // Ìï¥Îãπ ÏõîÏùò ÎßàÏßÄÎßâ ÎÇ† ÌôïÏù∏
        const lastDayOfMonth = new Date(targetYear, targetMonth, 0).getDate();
        const actualPaymentDay = Math.min(paymentDay, lastDayOfMonth);
        
        paymentDates.push(actualPaymentDay);
      }
      
      return paymentDates;
      
    } catch (error) {
      console.error('Error getting payment dates:', error);
      return [];
    }
  }

  // ÏõîÎ≥Ñ ÌïôÏäµ ÏãúÍ∞Ñ ÌÜµÍ≥Ñ
  async getMonthlyStudyStats(year: number, month: number): Promise<MonthlyStudyStats[]> {
    try {
      const db = await this.ensureDbConnection();
      
      // ÎØ∏Îûò Îã¨Ïù∏ Í≤ΩÏö∞ Îπà Î∞∞Ïó¥ Î∞òÌôò
      const now = new Date();
      const currentYear = now.getFullYear();
      const currentMonth = now.getMonth() + 1;
      
      if (year > currentYear || (year === currentYear && month > currentMonth)) {
        console.log(`üìä Future month requested: ${year}-${month}, returning empty study data`);
        return [];
      }
      
      const startDate = `${year}-${month.toString().padStart(2, '0')}-01`;
      const endDate = new Date(year, month, 0).toISOString().split('T')[0]; // Ìï¥Îãπ ÏõîÏùò ÎßàÏßÄÎßâ ÎÇ†
      
      console.log(`Getting study stats for ${startDate} to ${endDate}`);
      
      // 1. ÏùºÎ∞ò Ïù¥Î≤§Ìä∏Ïùò ÌïôÏäµ ÏãúÍ∞Ñ
      const regularEvents = await db.getAllAsync<any>(
        `SELECT 
          COALESCE(a.subject, 'Í∏∞ÌÉÄ') as subject,
          a.name as academy_name,
          e.start_time,
          e.end_time,
          e.event_date,
          e.category
        FROM events e
        LEFT JOIN academies a ON e.academy_id = a.id AND a.del_yn = 0
        WHERE e.del_yn = 0 
          AND e.is_recurring = 0
          AND e.event_date BETWEEN ? AND ?
          AND e.category IN ('ÌïôÏõê', 'Í≥µÎ∂Ä')`,
        [startDate, endDate]
      );
      
      // 2. Î∞òÎ≥µ Ïù¥Î≤§Ìä∏Ïùò ÌïôÏäµ ÏãúÍ∞Ñ
      const recurringEvents = await db.getAllAsync<any>(
        `SELECT 
          e.*, 
          COALESCE(a.subject, 'Í∏∞ÌÉÄ') as subject,
          a.name as academy_name,
          rp.monday, rp.tuesday, rp.wednesday, rp.thursday, 
          rp.friday, rp.saturday, rp.sunday, 
          rp.start_date, rp.end_date
        FROM events e
        LEFT JOIN academies a ON e.academy_id = a.id AND a.del_yn = 0
        INNER JOIN recurring_patterns rp ON e.recurring_group_id = rp.id
        WHERE e.del_yn = 0 
          AND e.is_recurring = 1
          AND rp.del_yn = 0
          AND rp.start_date <= ?
          AND (rp.end_date IS NULL OR rp.end_date >= ?)
          AND e.category IN ('ÌïôÏõê', 'Í≥µÎ∂Ä')`,
        [endDate, startDate]
      );
      
      console.log(`Found ${regularEvents.length} regular events, ${recurringEvents.length} recurring patterns`);
      
      // 3. ÏãúÍ∞Ñ Í≥ÑÏÇ∞ÏùÑ ÏúÑÌïú Ìó¨Ìçº Ìï®Ïàò
      const calculateHours = (startTime: string, endTime: string): number => {
        try {
          const [startHour, startMin] = startTime.split(':').map(Number);
          const [endHour, endMin] = endTime.split(':').map(Number);
          
          const startMinutes = startHour * 60 + startMin;
          const endMinutes = endHour * 60 + endMin;
          
          const diffMinutes = endMinutes - startMinutes;
          return diffMinutes > 0 ? diffMinutes / 60 : 0;
        } catch (error) {
          console.error('Error calculating hours:', error);
          return 0;
        }
      };
      
      // 4. Í≥ºÎ™©Î≥Ñ ÏãúÍ∞Ñ ÏßëÍ≥Ñ
      const subjectHours = new Map<string, number>();
      
      // ÏùºÎ∞ò Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
      for (const event of regularEvents) {
        const hours = calculateHours(event.start_time, event.end_time);
        const subject = event.subject || 'Í∏∞ÌÉÄ';
        subjectHours.set(subject, (subjectHours.get(subject) || 0) + hours);
      }
      
      // Î∞òÎ≥µ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
      for (const recurringEvent of recurringEvents) {
        const dates = this.generateRecurringDates(recurringEvent, startDate, endDate);
        const hours = calculateHours(recurringEvent.start_time, recurringEvent.end_time);
        const subject = recurringEvent.subject || 'Í∏∞ÌÉÄ';
        
        const totalHours = hours * dates.length;
        subjectHours.set(subject, (subjectHours.get(subject) || 0) + totalHours);
      }
      
      // 5. Í≤∞Í≥º Î≥ÄÌôò
      const result: MonthlyStudyStats[] = Array.from(subjectHours.entries()).map(([subject, total_hours]) => ({
        subject,
        total_hours: Math.round(total_hours * 100) / 100 // ÏÜåÏàòÏ†ê 2ÏûêÎ¶¨ÍπåÏßÄ
      })).sort((a, b) => b.total_hours - a.total_hours);
      
      console.log('Monthly study stats result:', result);
      return result;
    } catch (error) {
      console.error('Error getting monthly study stats:', error);
      throw error;
    }
  }
}

export default new DatabaseService();